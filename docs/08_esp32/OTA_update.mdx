---
sidebar_position: 6
title: "Actualización OTA"
description: "Guia para realizar actualizaciones Over-The-Air (OTA) en dispositivos ESP32."
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Actualización OTA
{/* TITLE: 1 */}
## Introducción
La actualizacón Over-The-Air (OTA) permite actualizar el firmware de un dispositivo ESP32 sin necesidad de conexión física. Esto es especialmente útil para dispositivos desplegados en ubicaciones remotas. La forma preferida de implementar OTA en ESP32 es utilizando un servidor web para alojar las actualizaciones de firmware.

<hr style={{marginTop: "40px"}} />
{/* TITLE: 1.1 */}
## Servidor
El primer paso es configurar un servidor web para alojar dos archivos esenciales:
- `firmware.bin`: El archivo binario del firmware que se va a actualizar.
- `version.txt`: Un archivo de texto que contiene la versión actual del firmware.

El dispositivo ESP32 verificará de la siguiente forma:
- Descargar `version.txt` desde el servidor.
- Comparar la versión en `version.txt` con la versión actual del firmware.
- Si la versión en el servidor es más reciente, procederá a descargar `firmware.bin` y actualizar el firmware.

Para el ejemplo, utilizaremos un servidor web simple al que se puede acceder desde `http://apuntes.christianherrera.com.ar/ota/`.


<hr style={{marginTop: "40px"}} />
{/* TITLE: 1.2 */}
## Sketch Básico
El microcontrolador tendrá dos funciones principales:

<br />
### Verificar la versión del firmware en el servidor.
Se utiliza el ejemplo visto en [Solicitud GET con HTTPS](./get_post_https#petición-get). La idea es solicitar el archivo `version.txt` y devolver la versión como un entero. En caso de error, se devolverá `-1`.

```cpp
int checkNewVersion() {
    // Verifica conexión WiFi
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi no conectado");
        return -1;
    }

    // Objetos y primeras configuraciones
    WiFiClientSecure client;
    HTTPClient http;
    client.setCACert(SERVER_ROOT_CA);
    http.setTimeout(5000);

    // Inicia conexión
    if (!http.begin(client, "https://apuntes.christianherrera.com.ar/ota/version.txt")) {
        return -1;
    }

    // Realiza la petición
    int httpCode = http.GET();
    if (httpCode != HTTP_CODE_OK) {
        Serial.printf("HTTP error: %d\n", httpCode);
        http.end();
        return -1;
    }

    // Leo el contenido de version.txt (máximo 7 bytes)
    char buf[8];
    memset(buf, 0, sizeof(buf));
    WiFiClient* stream = http.getStreamPtr();
    size_t len = stream->readBytesUntil('\n', buf, sizeof(buf) - 1);
    http.end();

    // Convierto a entero y comparo con el actual
    if (len == 0) return -1;
    return(atoi(buf));
}
```
En este ejemplo se ven algunos detalles importantes:
- Utiliza HTTPS para la conexión segura.
- Lee el contenido del archivo `version.txt` hasta un salto de línea.
- Utiliza un buffer de 8 bytes para almacenar la versión leída.
- La función retorna la version leida como un entero, o -1 en caso de error.

<br />
### Descargar y aplicar la actualización si es necesario.
La función para descargar y aplicar la actualización OTA es la siguiente:

```cpp
void processUpdate() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi no conectado");
        return;
    }

    // Objetos y primeras configuraciones
    WiFiClientSecure client;
    client.setCACert(SERVER_ROOT_CA);
    httpUpdate.rebootOnUpdate(true);

    // Inicia actualización OTA
    Serial.println("Iniciando OTA HTTPS...");
    t_httpUpdate_return ret = httpUpdate.update(client, "https://apuntes.christianherrera.com.ar/ota/firmware.bin");

    // Manejo de resultados
    if (ret == HTTP_UPDATE_FAILED) {
        Serial.printf("OTA falló (%d): %s\n", httpUpdate.getLastError(), httpUpdate.getLastErrorString().c_str());
    }
}
```
En este ejemplo:
- Se utiliza la función `httpUpdate.update()` para descargar y aplicar la actualización desde el servidor.
- Se maneja el resultado de la actualización, imprimiendo un mensaje en caso de fallo.
- Si la actualización es exitosa, el dispositivo se reiniciará automáticamente.


<br />
### Sketch Completo
A continuación se muestra un sketch completo que integra ambas funciones y realiza la verificación y actualización OTA.
Para el ejemplo, se utiliza las URL de `https://raw.githubusercontent.com/...` dado que es la url que devuelve el ***Content-Length*** del archivo `firmware.bin`. La url con dominio personal no devuelve este encabezado, lo que provoca un error en la actualización OTA.

<details>
<summary>Archivo de Configuración</summary>

```ini
[env:esp32-c3-devkitm-1]
platform = espressif32
board = esp32-c3-devkitm-1
framework = arduino
build_flags = 
	-D ARDUINO_USB_MODE=1
	-D ARDUINO_USB_CDC_ON_BOOT=1
	-D CORE_DEBUG_LEVEL=0
	-D FIRMWARE_VERSION=1

monitor_speed = 115200
monitor_filters = send_on_enter, time, esp32_exception_decoder, log2file
```
</details>

<details>
<summary>Sketch Completo</summary>

```cpp
#include <Arduino.h>
#include <HTTPClient.h>
#include <HTTPUpdate.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>

const char* host_ssid = "WIFI_SSID";
const char* host_pass = "WIFI_PASS";

char buffer[128];

const char SERVER_ROOT_CA[] = R"EOF(
-----BEGIN CERTIFICATE-----
MIIF3jCCA8agAwIBAgIQAf1tMPyjylGoG7xkDjUDLTANBgkqhkiG9w0BAQwFADCB
iDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0pl
cnNleSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNV
BAMTJVVTRVJUcnVzdCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAw
MjAxMDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBiDELMAkGA1UEBhMCVVMxEzARBgNV
BAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYDVQQKExVU
aGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBSU0EgQ2Vy
dGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
AoICAQCAEmUXNg7D2wiz0KxXDXbtzSfTTK1Qg2HiqiBNCS1kCdzOiZ/MPans9s/B
3PHTsdZ7NygRK0faOca8Ohm0X6a9fZ2jY0K2dvKpOyuR+OJv0OwWIJAJPuLodMkY
tJHUYmTbf6MG8YgYapAiPLz+E/CHFHv25B+O1ORRxhFnRghRy4YUVD+8M/5+bJz/
Fp0YvVGONaanZshyZ9shZrHUm3gDwFA66Mzw3LyeTP6vBZY1H1dat//O+T23LLb2
VN3I5xI6Ta5MirdcmrS3ID3KfyI0rn47aGYBROcBTkZTmzNg95S+UzeQc0PzMsNT
79uq/nROacdrjGCT3sTHDN/hMq7MkztReJVni+49Vv4M0GkPGw/zJSZrM233bkf6
c0Plfg6lZrEpfDKEY1WJxA3Bk1QwGROs0303p+tdOmw1XNtB1xLaqUkL39iAigmT
Yo61Zs8liM2EuLE/pDkP2QKe6xJMlXzzawWpXhaDzLhn4ugTncxbgtNMs+1b/97l
c6wjOy0AvzVVdAlJ2ElYGn+SNuZRkg7zJn0cTRe8yexDJtC/QV9AqURE9JnnV4ee
UB9XVKg+/XRjL7FQZQnmWEIuQxpMtPAlR1n6BB6T1CZGSlCBst6+eLf8ZxXhyVeE
Hg9j1uliutZfVS7qXMYoCAQlObgOK6nyTJccBz8NUvXt7y+CDwIDAQABo0IwQDAd
BgNVHQ4EFgQUU3m/WqorSs9UgOHYm8Cd8rIDZsswDgYDVR0PAQH/BAQDAgEGMA8G
A1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAFzUfA3P9wF9QZllDHPF
Up/L+M+ZBn8b2kMVn54CVVeWFPFSPCeHlCjtHzoBN6J2/FNQwISbxmtOuowhT6KO
VWKR82kV2LyI48SqC/3vqOlLVSoGIG1VeCkZ7l8wXEskEVX/JJpuXior7gtNn3/3
ATiUFJVDBwn7YKnuHKsSjKCaXqeYalltiz8I+8jRRa8YFWSQEg9zKC7F4iRO/Fjs
8PRF/iKz6y+O0tlFYQXBl2+odnKPi4w2r78NBc5xjeambx9spnFixdjQg3IM8WcR
iQycE0xyNN+81XHfqnHd4blsjDwSXWXavVcStkNr/+XeTWYRUc+ZruwXtuhxkYze
Sf7dNXGiFSeUHM9h4ya7b6NnJSFd5t0dCy5oGzuCr+yDZ4XUmFF0sbmZgIn/f3gZ
XHlKYC6SQK5MNyosycdiyA5d9zZbyuAlJQG03RoHnHcAP9Dc1ew91Pq7P8yF1m9/
qS3fuQL39ZeatTXaw2ewh0qpKJ4jjv9cJ2vhsE/zB+4ALtRZh8tSQZXq9EfX7mRB
VXyNWQKV3WKdwrnuWih0hKWbt5DHDAff9Yk2dDLWKMGwsAvgnEzDHNb842m1R0aB
L6KCq9NjRHDEjf8tM7qtj3u1cIiuPhnPQCjY/MiQu12ZIvVS5ljFH4gxQ+6IHdfG
jjxDah2nGN59PRbxYvnKkKj9
-----END CERTIFICATE-----
)EOF";

int checkNewVersion() {
    // Verifica conexión WiFi
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi no conectado");
        return -1;
    }

    // Objetos y primeras configuraciones
    WiFiClientSecure client;
    HTTPClient http;
    client.setCACert(SERVER_ROOT_CA);
    http.setTimeout(5000);

    // Inicia conexión
    if (!http.begin(client, "https://raw.githubusercontent.com/christian-herrera/apuntes/main/static/ota/version.txt")) {
        return -1;
    }

    // Realiza la petición
    int httpCode = http.GET();
    if (httpCode != HTTP_CODE_OK) {
        Serial.printf("HTTP error: %d\n", httpCode);
        http.end();
        return -1;
    }

    // Leo el contenido de version.txt (máximo 7 bytes)
    char buf[8];
    memset(buf, 0, sizeof(buf));
    WiFiClient* stream = http.getStreamPtr();
    size_t len = stream->readBytesUntil('\n', buf, sizeof(buf) - 1);
    http.end();

    // Convierto a entero y comparo con el actual
    if (len == 0) return -1;
    return(atoi(buf));
}

void processUpdate() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi no conectado");
        return;
    }

    // Objetos y primeras configuraciones
    WiFiClientSecure client;
    client.setCACert(SERVER_ROOT_CA);
    httpUpdate.rebootOnUpdate(true);
    httpUpdate.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);

    // Inicia actualización OTA
    Serial.println("Iniciando OTA HTTPS...");
    t_httpUpdate_return ret = httpUpdate.update(client, "https://raw.githubusercontent.com/christian-herrera/apuntes/main/static/ota/firmware.bin");

    // Manejo de resultados
    if (ret == HTTP_UPDATE_FAILED) {
        Serial.printf("OTA falló (%d): %s\n", httpUpdate.getLastError(), httpUpdate.getLastErrorString().c_str());
    }
}

void setup() {
    analogWrite(8, 255);
    Serial.begin(115200);
    delay(3000);

    // Modo STA
    WiFi.mode(WIFI_STA);
    WiFi.begin(host_ssid, host_pass);

    // Espera hasta conectarse
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
    }
    Serial.println("\nConectado!");

    // Verificacion
    analogWrite(8, 0);
    Serial.printf("Version actual: %d\n", FIRMWARE_VERSION);
    int newVersion = checkNewVersion();
    if(newVersion > FIRMWARE_VERSION) {
        Serial.printf("Nueva version disponible: %d (actual: %d)\n", newVersion, FIRMWARE_VERSION);
        delay(3000);
        processUpdate();
    } else {
        Serial.println("No hay nueva version disponible.");
    }
    analogWrite(8, 255);
    delay(1000);
}

void loop() {

    static unsigned long mark = 0;
    static int level = 0;
    static bool direction = false;
    if (millis() - mark > 10) {
        mark = millis();
        analogWrite(8, level);
        level = level + (direction ? 1 : -1);
        direction = (level >= 255) ? false : (level <= 0) ? true : direction;
    }
}
```
</details>