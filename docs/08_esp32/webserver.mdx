---
sidebar_position: 5
title: "Libreria WebServer.h"
description: "Guia para realizar un servidor web en ESP32."
---


# Libreria ESP32 WebServer
{/* TITLE: 1 */}
## Introducción
Una forma simple de crear un servidor web en el ESP32 es utilizando la libreria `ESP32 WebServer`. Esta libreria permite manejar solicitudes HTTP y servir paginas web de manera sencilla. A continuacion, el siguiente ejemplo muestra como se realiza la conexión a una red WiFi y como se configura el servidor web para responder a las solicitudes en la raiz (`/`).

```cpp
#include <Arduino.h>
#include <ESPmDNS.h>
#include <WebServer.h>
#include <WiFi.h>

const char* ssid = "WIFI-SSID";
const char* password = "WIFI-PASSWORD";

float temp, hum;
int rssi;
char buffer[128];

WebServer server(80);

const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ESP32-C3</title><style>
body{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;background:#eef1f5;color:#333;margin:0;padding:15px}
.c{background:#fff;padding:18px;border-radius:12px;text-align:center;box-shadow:0 4px 12px rgba(0,0,0,.08);flex:1 1 150px;display:flex;flex-direction:column;justify-content:space-between;min-height:90px;border-bottom:4px solid #007bff}
h1{color:#1a202c;text-align:center;margin-bottom:25px;font-size:1.8em}
h3{margin:0 0 5px;font-size:.9rem;color:#666;text-transform:uppercase;letter-spacing:1px}
p{margin:0;font-size:2.2rem;font-weight:700;color:#2c3e50}
span{font-size:.9rem;font-weight:400;color:#888;margin-left:5px}
.g{display:flex;flex-wrap:wrap;gap:15px;justify-content:center;max-width:900px;margin:0 auto}
</style></head><body>
<h1>ESP32-C3 Super Mini</h1><div class="g">
<div class="c"><h3>Temperatura</h3><p id="t">--<span>°C</span></p></div>
<div class="c"><h3>Humedad</h3><p id="h">--<span>%</span></p></div>
<div class="c"><h3>RSSI</h3><p id="v">--<span>dBm</span></p></div>
</div><script>
setInterval(()=>{fetch('/d').then(r=>r.json()).then(d=>{
document.getElementById('t').innerHTML=Number(d.t).toFixed(2)+'<span>°C</span>';
document.getElementById('h').innerHTML=Number(d.h).toFixed(2)+'<span>%</span>';
document.getElementById('v').innerHTML=d.v+'<span>dBm</span>';
})},3000);
</script></body></html>
)rawliteral";

void handleRoot() {
    server.send(200, "text/html", index_html);
}

void handleJsonData() {
    snprintf(buffer, sizeof(buffer), "{\"t\":%.2f,\"h\":%.2f,\"v\":%d}", temp, hum, rssi);
    server.send(200, "application/json", buffer);
}

void setup() {
    pinMode(8, OUTPUT);
    digitalWrite(8, HIGH);

    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
    }

    // --- mDNS ---
    if (!MDNS.begin("esp32")) {
        return;
    }

    // --- Web server ---
    server.on("/", handleRoot);
    server.on("/d", handleJsonData);
    server.begin();

    digitalWrite(8, LOW);    
}


void loop() {
    server.handleClient();

    static unsigned long lastUpdate = 0;
    if (millis() - lastUpdate > 100) {
        lastUpdate = millis();
        temp = 24 + (random(-500, 500) / 100.0);
        hum = 50 + (random(-2000, 2000) / 100.0);
    }
}
```

En este ejemplo, es importante destacar los siguientes puntos:

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
    {/* MARK: Pestaña HTML */}
    <TabItem value="1" label="HTML" default>
        El código HTML de la página web se define en la variable `index_html` utilizando la sintaxis de cadena cruda (raw string) para facilitar la inclusión de múltiples líneas y caracteres especiales. Incluye además:
        - Código CSS para el estilo de la página.
        - Código JavaScript con una simple funcion que solicita datos al servidor cada 3 segundos.
    </TabItem>


    {/* MARK: Pestaña Función Handle */}
    <TabItem value="2" label="Función Handle" >
        Las dos funciones usadas `handleRoot` y `handleJsonData` manejan las solicitudes HTTP para la raíz (`/`) y para la ruta `/d`, respectivamente. La primera envía la página HTML, mientras que la segunda envía datos en formato JSON.

        Es importante notar que en la función `handleJsonData`, se hace uso de las variables `temp`, `hum` y `rssi` las cuales son globales y se actualizan en el bucle principal (`loop`).
    </TabItem>

    {/* MARK: Pestaña Setup */}
    <TabItem value="3" label="Setup" >
        El ***setup*** primero realiza la conexión a la red WiFi utilizando las credenciales proporcionadas. Luego, configura el servicio mDNS para permitir el acceso al dispositivo mediante un nombre de host amigable (`esp32.local`). Finalmente, se configuran las rutas del servidor web y se inicia el servidor.

        Si todo fué correcto, se enciende el led en la pcb y el ESP32 estará accesible a través de la dirección `http://esp32.local` en un navegador web dentro de la misma red local.
    </TabItem>


    {/* MARK: Pestaña Loop */}
    <TabItem value="4" label="Loop" >
        En el bucle principal (`loop`), se maneja la atención de las solicitudes del servidor web mediante `server.handleClient()`. Además, se simulan valores de temperatura y humedad utilizando números aleatorios para demostrar la funcionalidad de actualización dinámica en la página web.

        En un escenario real, estos valores podrían ser obtenidos de sensores conectados al ESP32.    
    </TabItem>
</Tabs>


<hr style={{marginTop: "80px"}} />
{/* TITLE: 2 */}
## Atomizando el Sketch
Cuando el sketch comienza a crecer, es recomendable dividir el código en múltiples archivos para mejorar la organización y mantenibilidad. A continuación, se muestra cómo se podría estructurar el código anterior en varios archivos:



<Tabs>
    {/* MARK: Pestaña main.cpp */}
    <TabItem value="1" label="main.cpp" default>
        El código principal se mantiene en `main.cpp`, donde se inicializan las variables globales, y se llama a las funciones extras definidas en otros archivos.

        ```cpp
        #include <Arduino.h>
        #include "Network.h"

        float temp, hum;

        void setup() {
            pinMode(8, OUTPUT);
            digitalWrite(8, HIGH);

            if(!Network::init(&temp, &hum)){
                while(1){}
            }

            digitalWrite(8, LOW);
        }

        void loop() {
            Network::listen();

            static unsigned long lastUpdate = 0;
            if (millis() - lastUpdate > 100) {
                lastUpdate = millis();
                temp = 18 + (random(-500, 500) / 100.0);
                hum = 25 + (random(-2000, 2000) / 100.0);
            }
        }
        ```
    </TabItem>    

    {/* MARK: Pestaña config.h */}
    <TabItem value="2" label="include/config.h">
        El archivo de configuración contiene las credenciales de red y el certificado utilizado para la conexión segura.

        ```cpp
        #pragma once

        // Credenciales de Red
        constexpr const char* ssid = "Flia-Herrera";
        constexpr const char* password = "oceano2021";

        // Certificado SSL
        constexpr const char index_html[] = R"rawliteral(
        <!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ESP32-C3</title><style>
        body{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;background:#eef1f5;color:#333;margin:0;padding:15px}
        .c{background:#fff;padding:18px;border-radius:12px;text-align:center;box-shadow:0 4px 12px rgba(0,0,0,.08);flex:1 1 150px;display:flex;flex-direction:column;justify-content:space-between;min-height:90px;border-bottom:4px solid #007bff}
        h1{color:#1a202c;text-align:center;margin-bottom:25px;font-size:1.8em}
        h3{margin:0 0 5px;font-size:.9rem;color:#666;text-transform:uppercase;letter-spacing:1px}
        p{margin:0;font-size:2.2rem;font-weight:700;color:#2c3e50}
        span{font-size:.9rem;font-weight:400;color:#888;margin-left:5px}
        .g{display:flex;flex-wrap:wrap;gap:15px;justify-content:center;max-width:900px;margin:0 auto}
        </style></head><body>
        <h1>ESP32-C3 Super Mini</h1><div class="g">
        <div class="c"><h3>Temperatura</h3><p id="t">--<span>°C</span></p></div>
        <div class="c"><h3>Humedad</h3><p id="h">--<span>%</span></p></div>
        <div class="c"><h3>RSSI</h3><p id="v">--<span>dBm</span></p></div>
        </div><script>
        setInterval(()=>{fetch('/d').then(r=>r.json()).then(d=>{
        document.getElementById('t').innerHTML=Number(d.t).toFixed(2)+'<span>°C</span>';
        document.getElementById('h').innerHTML=Number(d.h).toFixed(2)+'<span>%</span>';
        document.getElementById('v').innerHTML=d.v+'<span>dBm</span>';
        })},3000);
        </script></body></html>
        )rawliteral";
        ``` 
    </TabItem>


    {/* MARK: Pestaña include/Network.h */}
    <TabItem value="3" label="lib/Network/Network.h">
        Este archivo contiene la declaración del namespace `Network` y las funciones públicas para inicializar y escuchar el servidor web.
        ```cpp
        #pragma once

        #include <Arduino.h>

        namespace Network {
            bool init(const float * temperature, const float * humidity);
            void listen();
        }
        ```
    </TabItem>

    {/* MARK: Pestaña include/Network.cpp */}
    <TabItem value="4" label="lib/Network/Network.cpp">
        En este archivo es donde se implementan las funciones del namespace `Network`.
        ```cpp
        #include "Network.h"

        #include <ESPmDNS.h>
        #include <WebServer.h>
        #include <WiFi.h>

        #include "../../include/config.h"

        // Variables, objetos y funciones que viven solo en este archivo
        namespace {
        static const float* tempPtr = nullptr;
        static const float* humPtr = nullptr;

        WebServer server(80);
        char buffer[50];

        }  // namespace

        // Namespace público
        namespace Network {
        bool init(const float* temperature, const float* humidity) {
            tempPtr = temperature;
            humPtr = humidity;

            WiFi.mode(WIFI_STA);
            WiFi.begin(ssid, password);

            // Conecta y espera hasta 10 segundos
            unsigned long start = millis();
            while (WiFi.status() != WL_CONNECTED && (millis() - start) < 10000) {
                delay(500);
            }

            // Verifica la conexion o el timeout
            if (WiFi.status() != WL_CONNECTED) {
                return false;
            }

            // Servidor mDNS
            if (!MDNS.begin("esp32")) {
                return false;
            }

            // Servidor HTTP
            server.on("/", []() { 
                server.send(200, "text/html", index_html); 
            });
            server.on("/d", []() {
                snprintf(buffer, sizeof(buffer), "{\"t\":%.2f,\"h\":%.2f,\"v\":%d}", *tempPtr, *humPtr, WiFi.RSSI());
                server.send(200, "application/json", buffer);
            });
            server.begin();

            return true;
        }

        void listen() { server.handleClient(); }
        }  // namespace Network
        ```
        En este archivo es importante diferenciar dos ***namespace***:
        - El namespace anónimo (sin nombre) que contiene variables y objetos privados que solo son accesibles dentro de este archivo.
        - El namespace `Network` que contiene las funciones públicas `init` y `listen`

        Notar que las variables `tempPtr` y `humPtr` son punteros a las variables globales definidas en `main.cpp`. Esto permite que el namespace `Network` acceda a los valores actualizados de temperatura y humedad sin necesidad de pasarlos como parámetros en cada solicitud.
    </TabItem>
</Tabs>