---
sidebar_position: 6
title: "Threads"
description: "Paquete threads de Python para manejo de hilos."
tags:
    - Python
    - Threads
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Threads
{/* TITLE: 1 */}
## Introducci√≥n
El m√≥dulo `threading` en Python proporciona una forma de crear y manejar hilos (threads) en un programa. Los hilos permiten la ejecuci√≥n concurrente de m√∫ltiples tareas dentro de un mismo proceso, lo que puede mejorar el rendimiento en aplicaciones que realizan operaciones de E/S o tareas que pueden ejecutarse en paralelo.

```python
import threading
import time

def tarea(nombre, operaciones, retraso):
    print(f"[{nombre}] Iniciando {operaciones} operaciones r√°pidas...")
    for i in range(operaciones):
        time.sleep(retraso)
        print(f"[{nombre}] Operaci√≥n {i+1}/{operaciones}")
    print(f"[{nombre}] ‚úì COMPLETADO")

def main():
    print("=" * 50 + "\nINICIANDO 2 THREADS EN PARALELO\n" + "=" * 50)

    thread1 = threading.Thread(target=tarea, args=("TAREA-LENTA", 5, 1))
    thread2 = threading.Thread(target=tarea, args=("TAREA-RAPIDA", 10, 0.3))

    thread1.start()
    thread2.start()

    print("\n" + "=" * 50 + "\nPROCESO PRINCIPAL\n" + "=" * 50)
    for i in range(4):
        time.sleep(1.2)
        print(f"[MAIN] Proceso principal trabajando... {i+1}/4")
    
    # Esperar a que terminen los threads no-daemon
    thread1.join()
    thread2.join()
    
    print("\n" + "=" * 50)

if __name__ == "__main__":
    main()
```

<details>
<summary>Salida por consola</summary>
```
==================================================
INICIANDO 2 THREADS EN PARALELO
==================================================
[TAREA-LENTA] Iniciando 5 operaciones r√°pidas...
[TAREA-RAPIDA] Iniciando 10 operaciones r√°pidas...

==================================================
PROCESO PRINCIPAL
==================================================
[TAREA-RAPIDA] Operaci√≥n 1/10
[TAREA-RAPIDA] Operaci√≥n 2/10
[TAREA-RAPIDA] Operaci√≥n 3/10
[TAREA-LENTA] Operaci√≥n 1/5
[MAIN] Proceso principal trabajando... 1/4
[TAREA-RAPIDA] Operaci√≥n 4/10
[TAREA-RAPIDA] Operaci√≥n 5/10
[TAREA-RAPIDA] Operaci√≥n 6/10
[TAREA-LENTA] Operaci√≥n 2/5
[TAREA-RAPIDA] Operaci√≥n 7/10
[MAIN] Proceso principal trabajando... 2/4
[TAREA-RAPIDA] Operaci√≥n 8/10
[TAREA-RAPIDA] Operaci√≥n 9/10
[TAREA-LENTA] Operaci√≥n 3/5
[TAREA-RAPIDA] Operaci√≥n 10/10
[TAREA-RAPIDA] ‚úì COMPLETADO
[MAIN] Proceso principal trabajando... 3/4
[TAREA-LENTA] Operaci√≥n 4/5
[MAIN] Proceso principal trabajando... 4/4
[TAREA-LENTA] Operaci√≥n 5/5
[TAREA-LENTA] ‚úì COMPLETADO

==================================================
```
</details>

En este ejemplo se puede ver que se crean dos hilos que ejecutan la funci√≥n `tarea` con diferentes par√°metros. Mientras los hilos est√°n en ejecuci√≥n, el proceso principal contin√∫a trabajando de manera independiente. Al final, se espera a que ambos hilos terminen antes de finalizar el programa.



<br />

{/* TITLE: 2 */}
## Funciones T√≠picas
Para la creaci√≥n de un hilo se utiliza la siguiente instrucci√≥n:

```python
import threading

t = threading.Thread(target=funcion, args=(arg1, arg2), kwargs={'key': valor})
```

<Tabs>
    {/* MARK: Pesta√±a Clase Fundamental */}
    <TabItem value="clase" label="Clase Fundamental" default>
        - `t.start()`: Inicia la ejecuci√≥n del thread
        - `t.join(timeout=5)`: Espera a que termine (opcional timeout)
        - `t.is_alive()`: Devuelve True si el thread a√∫n est√° ejecut√°ndose
        - `t.getName()`: Obtiene el nombre del thread (obsoleto en Python 3)
        - `t.name`: Obtiene o establece el nombre (atributo)
        - `t.setName("nuevo")`: Establece el nombre (obsoleto)
        - `t.ident`: ID √∫nico del thread (None si no iniciado)
        - `t.native_id`: ID del thread en el sistema operativo (Python 3.8+)
        - `t.daemon`: Atributo booleano (True = thread daemon)
        - `t.isDaemon()`: ¬øEs daemon? (obsoleto)
        - `t.setDaemon(True)`: Establecer como daemon (obsoleto)
    </TabItem>    

    {/* MARK: Pesta√±a Funciones del M√≥dulo */}
    <TabItem value="modulo" label="Funciones del M√≥dulo" default>
        - `threading.active_count()`: N√∫mero de threads activos
        - `threading.current_thread()`: Devuelve el objeto Thread actual
        - `threading.main_thread()`: Devuelve el thread principal
        - `threading.enumerate()`: Lista de todos los objetos Thread activos
        - `threading.get_ident()`: ID del thread actual (entero)
        - `threading.get_native_id()`: ID nativo del thread actual (Python 3.8+)
        - `threading.settrace(func)`: Establece funci√≥n trace para todos los threads
        - `threading.setprofile(func)`: Establece funci√≥n profile para todos los threads
    </TabItem>
</Tabs>


<br />

{/* TITLE: 3 */}
## Locks y RLocks
Los locks (bloqueos) son mecanismos de sincronizaci√≥n que se utilizan para evitar condiciones de carrera cuando m√∫ltiples hilos acceden a recursos compartidos. Un `Lock` permite que solo un hilo acceda a un recurso a la vez, mientras que un `RLock` (reentrant lock) permite que el mismo hilo adquiera el bloqueo m√∫ltiples veces sin causar un bloqueo.

<details>
<summary>Ejemplo con Lock</summary>
```python
import threading
import time

# Creamos un Lock (llave √∫nica del ba√±o)
lock_banio = threading.Lock()

def usar_banio(persona):
    """Intenta usar el ba√±o con Lock"""
    print(f"[{persona}] Se acerca al ba√±o...")
    
    # INTENTA agarrar la llave
    conseguido = lock_banio.acquire(blocking=False)
    
    if conseguido: # No estaba ocupado, entonces usa el ba√±o
        print(f"  ‚úÖ [{persona}] AGARR√ì LA LLAVE")
        time.sleep(2)
        print(f"  ‚ùå [{persona}] DEVOLVI√ì LA LLAVE")
        lock_banio.release()
    else:
        print(f"  üö´ [{persona}] Ba√±o OCUPADO, se va")
        time.sleep(0.5)
        usar_banio(persona)  # <-- INTENTA NUEVAMENTE. OJO: Recursividad!

# Ejecutar
print("üîí EJEMPLO LOCK - BA√ëO P√öBLICO\n" + "-" * 40)

personas = ["Ana", "Carlos", "Beatriz"]
threads = []

for persona in personas:
    t = threading.Thread(target=usar_banio, args=(persona,))
    threads.append(t)
    t.start()
    time.sleep(0.3)  # Llegan con diferencia

for t in threads:  # Espera a que terminen todos
    t.join()
```
Esto, simula un ba√±o p√∫blico donde solo una persona puede usar el ba√±o a la vez. Si alguien intenta usar el ba√±o mientras est√° ocupado, esperar√° y lo intentar√° de nuevo.
La salida por consola podr√≠a ser algo as√≠:
```
üîí EJEMPLO LOCK - BA√ëO P√öBLICO
----------------------------------------
[Ana] Se acerca al ba√±o...
  ‚úÖ [Ana] AGARR√ì LA LLAVE
[Carlos] Se acerca al ba√±o...
  üö´ [Carlos] Ba√±o OCUPADO, se va
[Beatriz] Se acerca al ba√±o...
  üö´ [Beatriz] Ba√±o OCUPADO, se va
[Carlos] Se acerca al ba√±o...
  üö´ [Carlos] Ba√±o OCUPADO, se va
[Beatriz] Se acerca al ba√±o...
  üö´ [Beatriz] Ba√±o OCUPADO, se va
[Carlos] Se acerca al ba√±o...
  üö´ [Carlos] Ba√±o OCUPADO, se va
[Beatriz] Se acerca al ba√±o...
  üö´ [Beatriz] Ba√±o OCUPADO, se va
[Carlos] Se acerca al ba√±o...
  üö´ [Carlos] Ba√±o OCUPADO, se va
  ‚ùå [Ana] DEVOLVI√ì LA LLAVE
[Beatriz] Se acerca al ba√±o...
  ‚úÖ [Beatriz] AGARR√ì LA LLAVE
[Carlos] Se acerca al ba√±o...
  üö´ [Carlos] Ba√±o OCUPADO, se va
[Carlos] Se acerca al ba√±o...
  üö´ [Carlos] Ba√±o OCUPADO, se va
[Carlos] Se acerca al ba√±o...
  üö´ [Carlos] Ba√±o OCUPADO, se va
[Carlos] Se acerca al ba√±o...
  üö´ [Carlos] Ba√±o OCUPADO, se va
  ‚ùå [Beatriz] DEVOLVI√ì LA LLAVE
[Carlos] Se acerca al ba√±o...
  ‚úÖ [Carlos] AGARR√ì LA LLAVE
  ‚ùå [Carlos] DEVOLVI√ì LA LLAVE
```
Lo cual indica que solamente la persona que usa el ba√±o puede tener la "llave" (lock) en ese momento. Dejando a las demas personas esperando hasta que el ba√±o est√© libre.
</details>


<details>
<summary>Ejemplo con RLock</summary>

**RLock** permite que el mismo hilo pueda adquirir el bloqueo m√∫ltiples veces sin causar un bloqueo. Esto es √∫til en situaciones donde una funci√≥n que adquiere un bloqueo llama a otra funci√≥n que tambi√©n intenta adquirir el mismo bloqueo.
```python
import threading
import time

# RLock: el mismo hilo puede entrar varias veces
archivo_lock = threading.RLock()

def escribir_archivo():
    print("  ‚úçÔ∏è  Intentando escribir en el archivo...")
    with archivo_lock:
        print("  ‚úÖ Escribiendo...")
        time.sleep(1)

def procesar_archivo():
    print("üìÇ Intentando procesar archivo...")
    with archivo_lock:
        print("üìÇ Archivo abierto")
        escribir_archivo()
        print("üìÇ Archivo cerrado")

def trabajador(nombre):
    print(f"[{nombre}] Inicia trabajo")
    procesar_archivo()
    print(f"[{nombre}] Termina trabajo\n")

# Ejecutar
hilo = threading.Thread(target=trabajador, args=("Hilo-1",))
hilo.start()
hilo.join()
```
En este ejemplo, se v√© que:
- El hilo "Hilo-1" inicia el trabajo y llama a `procesar_archivo`.
- Dentro de `procesar_archivo`, se adquiere el `RLock` y luego se llama a `escribir_archivo`, que tambi√©n intenta adquirir el mismo `RLock`.
- Gracias a que es un `RLock`, el mismo hilo puede adquirir el bloqueo nuevamente sin bloquearse a s√≠ mismo.

La salida por consola ser√≠a:
```
[Hilo-1] Inicia trabajo
üìÇ Intentando procesar archivo...
üìÇ Archivo abierto
  ‚úçÔ∏è  Intentando escribir en el archivo...
  ‚úÖ Escribiendo...
üìÇ Archivo cerrado
[Hilo-1] Termina trabajo
```
</details>


<br />

{/* TITLE: 4 */}
## Semaforos
Un semaforo es un mecanismo de sincronizaci√≥n que controla el acceso a un recurso compartido mediante el uso de contadores. A diferencia de los locks, que permiten el acceso exclusivo a un recurso, los sem√°foros permiten que m√∫ltiples hilos accedan a un recurso hasta un l√≠mite definido.

- Permite que hasta N hilos entren a una secci√≥n cr√≠tica
- Cuando se acaban los permisos ‚Üí los dem√°s esperan

```python
import threading
import time

# 2 lugares disponibles
estacionamiento = threading.Semaphore(2)

def auto(nombre):
    print(f"üöó {nombre} quiere entrar")
    
    with estacionamiento:
        print(f"  ‚úÖ {nombre} estacion√≥, espera 2 segundos...")
        time.sleep(2)
        print(f"  üö™ {nombre} sale")

autos = ["Auto 1", "Auto 2", "Auto 3", "Auto 4"]
hilos = []

for a in autos: # Crear y arrancar un hilo por cada auto
    t = threading.Thread(target=auto, args=(a,))
    hilos.append(t)
    t.start()
    time.sleep(0.3)

for t in hilos: # Esperar a que todos los hilos terminen
    t.join()
``` 
Esto simula un estacionamiento con solo 2 espacios disponibles. Los autos intentan entrar, y si hay espacio, pueden estacionarse; de lo contrario, esperan hasta que haya un espacio libre.
La salida por consola podr√≠a ser algo as√≠:
```
üöó Auto 1 quiere entrar
  ‚úÖ Auto 1 estacion√≥, espera 2 segundos...
üöó Auto 2 quiere entrar
  ‚úÖ Auto 2 estacion√≥, espera 2 segundos...
üöó Auto 3 quiere entrar
üöó Auto 4 quiere entrar
  üö™ Auto 1 sale
  ‚úÖ Auto 3 estacion√≥, espera 2 segundos...
  üö™ Auto 2 sale
  ‚úÖ Auto 4 estacion√≥, espera 2 segundos...
  üö™ Auto 3 sale
  üö™ Auto 4 sale
```