"use strict";(globalThis.webpackChunkweb_apuntes=globalThis.webpackChunkweb_apuntes||[]).push([[631],{1470:(e,n,r)=>{r.d(n,{A:()=>k});var a=r(6540),i=r(4164),s=r(7559),l=r(3104),t=r(6347),c=r(205),o=r(7485),d=r(1682),u=r(679);function h(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:r}=e;return(0,a.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:r,default:a}})=>({value:e,label:n,attributes:r,default:a}))}(r);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,r])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function x({queryString:e=!1,groupId:n}){const r=(0,t.W6)(),i=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,o.aZ)(i),(0,a.useCallback)(e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})},[i,r])]}function j(e){const{defaultValue:n,queryString:r=!1,groupId:i}=e,s=p(e),[l,t]=(0,a.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find(e=>e.default)??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s})),[o,d]=x({queryString:r,groupId:i}),[h,j]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[r,i]=(0,u.Dv)(n);return[r,(0,a.useCallback)(e=>{n&&i.set(e)},[n,i])]}({groupId:i}),b=(()=>{const e=o??h;return m({value:e,tabValues:s})?e:null})();(0,c.A)(()=>{b&&t(b)},[b]);return{selectedValue:l,selectValue:(0,a.useCallback)(e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);t(e),d(e),j(e)},[d,j,s]),tabValues:s}}var b=r(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=r(4848);function v({className:e,block:n,selectedValue:r,selectValue:a,tabValues:s}){const t=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.a_)(),o=e=>{const n=e.currentTarget,i=t.indexOf(n),l=s[i].value;l!==r&&(c(n),a(l))},d=e=>{let n=null;switch(e.key){case"Enter":o(e);break;case"ArrowRight":{const r=t.indexOf(e.currentTarget)+1;n=t[r]??t[0];break}case"ArrowLeft":{const r=t.indexOf(e.currentTarget)-1;n=t[r]??t[t.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:a})=>(0,f.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{t.push(e)},onKeyDown:d,onClick:o,...a,className:(0,i.A)("tabs__item",y.tabItem,a?.className,{"tabs__item--active":r===e}),children:n??e},e))})}function g({lazy:e,children:n,selectedValue:r}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===r);return e?(0,a.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function E(e){const n=j(e);return(0,f.jsxs)("div",{className:(0,i.A)(s.G.tabs.container,"tabs-container",y.tabList),children:[(0,f.jsx)(v,{...n,...e}),(0,f.jsx)(g,{...n,...e})]})}function k(e){const n=(0,b.A)();return(0,f.jsx)(E,{...e,children:h(e.children)},String(n))}},3942:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"python/pyserial","title":"PySerial","description":"Paquete de Python para comunicaci\xf3n serial.","source":"@site/docs/07_python/pyserial.mdx","sourceDirName":"07_python","slug":"/python/pyserial","permalink":"/docs/python/pyserial","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Python","permalink":"/docs/tags/python"},{"inline":true,"label":"PySerial","permalink":"/docs/tags/py-serial"}],"version":"current","lastUpdatedAt":1767580864000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"PySerial","description":"Paquete de Python para comunicaci\xf3n serial.","tags":["Python","PySerial"]},"sidebar":"tutorialSidebar","previous":{"title":"Clases","permalink":"/docs/python/clases"},"next":{"title":"Threads","permalink":"/docs/python/threads"}}');var i=r(4848),s=r(8453),l=r(1470),t=r(9365);const c={sidebar_position:5,title:"PySerial",description:"Paquete de Python para comunicaci\xf3n serial.",tags:["Python","PySerial"]},o="PySerial",d={},u=[{value:"Introducci\xf3n",id:"introducci\xf3n",level:2},{value:"Ejemplo B\xe1sico",id:"ejemplo-b\xe1sico",level:2},{value:"Escribir Datos",id:"escribir-datos",level:2},{value:"Leer Datos",id:"leer-datos",level:2},{value:"Print vs Write (en Arduino)",id:"print-vs-write-en-arduino",level:2},{value:"Usando Print",id:"usando-print",level:3},{value:"Usando Write",id:"usando-write",level:3},{value:"Checksum",id:"checksum",level:2}];function h(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"pyserial",children:"PySerial"})}),"\n",(0,i.jsx)(n.h2,{id:"introducci\xf3n",children:"Introducci\xf3n"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"pyserial"})})," es la librer\xeda est\xe1ndar de Python para comunicaci\xf3n serie (UART):"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Arduino"}),"\n",(0,i.jsx)(n.li,{children:"ESP8266 ESP32"}),"\n",(0,i.jsx)(n.li,{children:"STM32"}),"\n",(0,i.jsx)(n.li,{children:"USB-Serial (FTDI, CH340, CP210x)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["En el lado Arduino, siempre se utiliza ",(0,i.jsx)(n.code,{children:"Serial"}),".\r\nEn Python, siempre se utiliza ",(0,i.jsx)(n.code,{children:"serial.Serial"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Se instala con pip: ",(0,i.jsx)(n.code,{children:"pip install pyserial"})," para luego importar con ",(0,i.jsx)(n.code,{children:"import serial"}),"."]}),"\n",(0,i.jsx)("br",{}),"\n","\n",(0,i.jsx)(n.h2,{id:"ejemplo-b\xe1sico",children:"Ejemplo B\xe1sico"}),"\n",(0,i.jsxs)(n.p,{children:["Todo gira alrededor de la clase ",(0,i.jsx)(n.code,{children:"serial.serial"}),", la cual se utiliza para crear un objeto que representa el puerto serie."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'com = serial.Serial(\r\n    port="/dev/ttyUSB0",\r\n    baudrate=115200,\r\n    timeout=1\r\n)\r\n\r\nif com.is_open:\r\n    print("Puerto abierto correctamente")\r\n    # ........\r\n    com.close()\n'})}),"\n",(0,i.jsx)(n.p,{children:"Algunos de los par\xe1metros mas importantes son:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"port"}),": Puerto serie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baudrate"}),": Velocidad (debe coincidir con Arduino)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timeout"}),": Tiempo m\xe1ximo de espera en lectura (",(0,i.jsx)(n.code,{children:"None"})," espera indefinidamente, ",(0,i.jsx)(n.code,{children:"0"})," no espera y ",(0,i.jsx)(n.code,{children:">0"})," espera esa cantidad de segundos)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"bytesize"}),": 8 por defecto"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parity"}),": serial.PARITY_NONE"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stopbits"}),": 1 por defecto"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Es importante notar:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"El puerto se crea y se abre en la misma l\xednea."}),"\n",(0,i.jsxs)(n.li,{children:["Se puede verificar si el puerto est\xe1 abierto con ",(0,i.jsx)(n.code,{children:"is_open"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Siempre es buena pr\xe1ctica cerrar el puerto con ",(0,i.jsx)(n.code,{children:"close()"}),"."]}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n","\n",(0,i.jsx)(n.h2,{id:"escribir-datos",children:"Escribir Datos"}),"\n",(0,i.jsxs)(n.p,{children:["Para enviar datos al dispositivo serie, se utiliza el m\xe9todo ",(0,i.jsx)(n.code,{children:"write()"}),", el cual recibe un objeto de tipo bytes."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"write()"})," siempre env\xeda bytes, nunca strings..."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'com.write("Hola Mundo")                     # ERROR (porque es str)\r\n\r\n# Las siguientes opciones son correctas dado que se convierte de str a bytes\r\ncom.write(b"Hola Mundo")                    # Encoding literal\r\ncom.write("Hola Mundo".encode())            # Encoding por defecto (utf-8)\r\ncom.write("Hola Mundo".encode(\'ascii\'))     # Encoding ASCII\r\ncom.write("Hola Mundo".encode(\'utf-8\'))     # Encoding UTF-8\n'})}),"\n",(0,i.jsx)(n.p,{children:"Es importante entender las diferencias entre las distintas codificaciones:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ascii"}),": Solo caracteres del 0 al 127 (Ingl\xe9s)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"utf-8"}),": Todos los caracteres (Espa\xf1ol, Chino, \xc1rabe, Emojis, etc.)"]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Tambi\xe9n es buena pr\xe1ctica agregar un salto de l\xednea al final de cada mensaje, para facilitar la lectura en el lado del dispositivo serie (Arduino, ESP32, etc.)"}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n","\n",(0,i.jsx)(n.h2,{id:"leer-datos",children:"Leer Datos"}),"\n",(0,i.jsxs)(n.p,{children:["Para leer datos desde el dispositivo serie, se utilizan los m\xe9todos ",(0,i.jsx)(n.code,{children:"read()"}),", ",(0,i.jsx)(n.code,{children:"readline()"}),", ",(0,i.jsx)(n.code,{children:"readlines()"})," o ",(0,i.jsx)(n.code,{children:"read_until()"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Se puede consultar la cantidad de bytes que hay disponibles para leer en el buffer de entrada con ",(0,i.jsx)(n.code,{children:"com.in_waiting"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(l.A,{children:[(0,i.jsxs)(t.A,{value:"read",label:"read()",default:!0,children:[(0,i.jsx)(n.p,{children:"Devuelve una cantidad espec\xedfica de bytes. Es bloqueante hasta que se reciben los bytes solicitados o se alcanza el timeout."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"data = com.read(10)          # Lee hasta 10 bytes.\r\nprint(data.decode())\n"})})]}),(0,i.jsxs)(t.A,{value:"readline",label:"readline()",children:[(0,i.jsxs)(n.p,{children:["Funciona similar a ",(0,i.jsx)(n.code,{children:"read()"}),", pero lee hasta encontrar un salto de l\xednea (",(0,i.jsx)(n.code,{children:"\\n"}),"). Tambi\xe9n es bloqueante."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"data = com.readline()\r\nprint(data.decode())\n"})}),(0,i.jsx)(n.p,{children:"Desde arduino, se puede enviar datos con:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'Serial.println("Hola Mundo");  // A\xf1ade \\r\\n autom\xe1ticamente\n'})})]}),(0,i.jsxs)(t.A,{value:"readlines",label:"readlines()",children:[(0,i.jsxs)(n.p,{children:["Funciona similar a ",(0,i.jsx)(n.code,{children:"read()"}),", pero lee todas las l\xedneas disponibles en el buffer de entrada."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"data = com.readlines()\r\nprint(data.decode())\n"})})]}),(0,i.jsxs)(t.A,{value:"read_until",label:"read_until()",children:[(0,i.jsx)(n.p,{children:"Esta funci\xf3n permite leer datos hasta encontrar un delimitador espec\xedfico o hasta alcanzar un n\xfamero m\xe1ximo de bytes."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"data = com.read_until(expected=b'FIN')   # Lee hasta encontrar 'FIN'\r\ndata = com.read_until(expected=b'\\r\\n')  # Lee hasta encontrar '\\r\\n'\r\ndata = com.read_until(expected=b'!')     # Lee hasta encontrar '!'\r\nprint(data.decode())\n"})}),(0,i.jsxs)(n.p,{children:["Tambi\xe9n se puede especificar un n\xfamero m\xe1ximo de bytes a leer utilizando el argumento ",(0,i.jsx)(n.code,{children:"size"}),"."]})]})]}),"\n",(0,i.jsx)("br",{}),"\n","\n",(0,i.jsx)(n.h2,{id:"print-vs-write-en-arduino",children:"Print vs Write (en Arduino)"}),"\n",(0,i.jsx)(n.h3,{id:"usando-print",children:"Usando Print"}),"\n",(0,i.jsx)(n.p,{children:"En Arduino se puede usar:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'uint16_t val1 = 123;\r\nuint16_t val2 = 456;\r\n\r\nSerial.print("#");       // Env\xeda el caracter \'#\'\r\nSerial.print(val1);      // Env\xeda "123" (3 caracteres)\r\nSerial.print(",");       // Env\xeda el caracter \',\'\r\nSerial.print(val2);      // Env\xeda "456" (3 caracteres)\r\nSerial.println("&");     // Env\xeda "&" + "\\r\\n"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Esto imprime el string: ",(0,i.jsx)(n.code,{children:"#123,456&\\r\\n"})," pero el problema de esto es que es un tama\xf1o variable ya que al convertir a ASCII, cada n\xfamero puede ocupar diferente cantidad de caracteres."]}),"\n",(0,i.jsx)(n.p,{children:"Para recibirlo en Python, se utiliza:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"data = com.readline()          # Lee hasta \\n\r\nprint(data.decode())           # Imprime: #123,456&\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"usando-write",children:"Usando Write"}),"\n",(0,i.jsx)(n.p,{children:"En Arduino se puede usar:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"typedef struct {\r\n    uint16_t val1, val2;\r\n} Data_t;\r\nData_t data = {123, 456};\r\n\r\nSerial.write('#');                              // Env\xeda byte b'#' (35)'\r\nSerial.write((uint8_t *)&data, sizeof(Data_t)); // Env\xeda 4 bytes (2 bytes por cada uint16_t)\r\nSerial.write('&');                              // Env\xeda byte b'&' (38)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Esto imprime todos los valores pero en formato binario, ocupando siempre el mismo tama\xf1o (6 bytes en total)."}),"\n",(0,i.jsx)(n.p,{children:"Para recibirlo en Python, se utiliza:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import struct\r\n\r\ndata = com.read_until(b'&')                                         # Lee hasta encontrar b'&'\r\ninitMark, val1, val2, endMark = struct.unpack('<cHHc', data)        # Desempaqueta los datos\r\nprint(f\"Marcas: {initMark} y {endMark}, Valores: {val1}, {val2}\")   # Imprime...\n"})}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsxs)("summary",{children:["Notas sobre ",(0,i.jsx)(n.code,{children:"struct"})]}),(0,i.jsxs)(n.p,{children:["El paquete ",(0,i.jsx)(n.code,{children:"struct"})," permite empaquetar y desempaquetar datos binarios en Python.\r\nEl formato est\xe1 compuesto por caracteres que indican el orden de los bytes, el tipo de dato y su tama\xf1o."]}),(0,i.jsxs)(n.p,{children:["El orden de los bytes puede ser (el indicado para usar con Arduino es ",(0,i.jsx)(n.em,{children:"Little-endian"}),"):"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@"}),": Nativo (por defecto)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"="}),": Nativo (sin alineaci\xf3n)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:">"}),": Big-endian"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<"}),": Little-endian"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"!"}),": Network (Big-endian)"]}),"\n"]}),(0,i.jsx)(n.p,{children:"El tipo y tama\xf1o se define con:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"?"}),": bool (1 byte)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"c"}),": char (1 byte)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"b"})," y ",(0,i.jsx)(n.code,{children:"B"}),": signed y unsigned char (1 byte)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"h"})," y ",(0,i.jsx)(n.code,{children:"H"}),": signed y unsigned short (2 bytes)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"i"})," y ",(0,i.jsx)(n.code,{children:"I"}),": signed y unsigned int (4 bytes)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"l"})," y ",(0,i.jsx)(n.code,{children:"L"}),": signed y unsigned long (4 bytes)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"q"})," y ",(0,i.jsx)(n.code,{children:"Q"}),": signed y unsigned long long (8 bytes)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"f"}),": float (4 bytes)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"d"}),": double (8 bytes)"]}),"\n"]})]}),"\n",(0,i.jsx)("br",{}),"\n","\n",(0,i.jsx)(n.h2,{id:"checksum",children:"Checksum"}),"\n",(0,i.jsx)(n.p,{children:"Para asegurar la integridad de los datos transmitidos, es com\xfan utilizar un checksum.\r\nUn checksum es un valor calculado a partir de los datos que se env\xedan, y se utiliza para verificar que los datos no han sido alterados durante la transmisi\xf3n."}),"\n",(0,i.jsx)(n.p,{children:"Suponiendo el siguiente paquete que se env\xeda desde Arduino:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"[#][counter][ch1][ch2][ch3][ch4][checksum][&]\r\n \u25141B   \u25142B    \u25142B  \u25142B  \u25142B  \u25142B    \u25141B   \u25141B   -> Total: 13 Bytes\n"})}),"\n",(0,i.jsx)(n.p,{children:"La operaci\xf3n XOR se realiza de la siguiente manera:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Recorre desde ",(0,i.jsx)(n.code,{children:"counter"})," hasta ",(0,i.jsx)(n.code,{children:"ch4"})," byte a byte."]}),"\n",(0,i.jsx)(n.li,{children:"Por cada byte, realiza una operaci\xf3n XOR con el valor acumulado del checksum."}),"\n",(0,i.jsx)(n.li,{children:"El resultado final es el valor del checksum que se env\xeda."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Esto garantiza las siguientes caracteristicas:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Cuando se realiza la misma operaci\xf3n XOR en el receptor, si se adiciona la operaci\xf3n XOR con el checksum recibido, deber\xeda dar cero. Esto puede simplificar las operaciones."}),"\n",(0,i.jsx)(n.li,{children:"Detecta si un byte se mov\xedo de posicion, ya que XOR(A,B,C) != XOR(A,C,B)"}),"\n",(0,i.jsx)(n.li,{children:"Cada bit del checksum depende igualmente de todos los bytes."}),"\n",(0,i.jsx)(n.li,{children:"La operaci\xf3n XOR siempre da un resultado de 1 byte (0-255)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Entonces, un Checksum simple para mover un payload desde Arduino a Python podr\xeda ser:"}),"\n",(0,i.jsxs)(l.A,{children:[(0,i.jsxs)(t.A,{value:"arduino",label:"Arduino",children:[(0,i.jsx)(n.p,{children:"Suponiendo que se tiene una estructura:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"typedef struct {\r\n    uint16_t counter;\r\n    uint16_t ch1, ch2, ch3, ch4;\r\n} Payload_t;\r\nPayload_t data;\n"})}),(0,i.jsx)(n.p,{children:"Se procede a hacer el env\xedo con checksum de la siguiente forma:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Fijo los valores del payload\r\ndata.counter++;\r\ndata.ch1 = ...; data.ch2 = ...; data.ch3 = ...; data.ch4 = ...;\r\n\r\n// Calculo el checksum\r\ndata.checksum = 0;\r\nuint8_t *ptr = (uint8_t *)&data;                    // Puntero al inicio del payload\r\nfor (size_t i = 0; i < sizeof(Payload_t); i++)      // Recorre byte a byte, acumulando el XOR\r\n    data.checksum ^= *(ptr + i);\r\n\r\n// Env\xedo los datos por Serial\r\nSerial.write('#');                                  // Marca de inicio\r\nSerial.write((uint8_t *)&data, sizeof(Payload_t));  // Payload + Checksum\r\nSerial.write('&');                                  // Marca de fin\n"})}),(0,i.jsx)(n.p,{children:"De esta forma, se env\xeda el paquete de forma binaria con el checksum incluido. En total se tienen 13 bytes."})]}),(0,i.jsxs)(t.A,{value:"python",label:"Python",default:!0,children:[(0,i.jsx)(n.p,{children:"En Python, la estructura b\xe1sica para recibir y verificar el paquete con checksum ser\xeda:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import struct\r\nimport serial\r\n\r\n# Creo la conexi\xf3n\r\ncom = serial.Serial(port=\"/dev/ttyUSB0\", baudrate=115200, timeout=1)\r\n\r\n# Leo el paquete completo hasta encontrar la marca de fin '&'\r\npacket = com.read_until(b'&')\r\n\r\n# Si el tama\xf1o del paquete es correcto, lo desempaqueto\r\nif len(packet) == 13:\r\n    _init, counter, ch1, ch2, ch3, ch4, checksum, _end = struct.unpack('<cHHHHHBc', packet)\r\n    \r\n    # Verifico las marcas de inicio y fin\r\n    if _init != b'#' or _end != b'&':\r\n        print(\"Error: Marcas de inicio o fin incorrectas\")\r\n        return False\r\n\r\n    # Verifico el checksum\r\n    # Esto se hace recorriendo byte a byte y acumulando el resultado de la operaci\xf3n XOR\r\n    calc_checksum = 0\r\n    for byte in packet[1:-1]:\r\n        calc_checksum ^= byte\r\n\r\n    # Dado que inclu\xed el checksum en el c\xe1lculo, el resultado debe ser 0\r\n    if calc_checksum == 0:\r\n        print(f\"Datos:\\t{counter}\\t{ch1}\\t{ch2}\\t{ch3}\\t{ch4}\")\r\n        return True\r\n    else:\r\n        print(\"Error: Checksum inv\xe1lido\")\r\n        return False\r\nelse:\r\n    print(\"Error: Tama\xf1o de paquete incorrecto\")\n"})}),(0,i.jsx)(n.p,{children:"Esto se deber\xeda implementar en un bucle para ir leyendo continuamente los datos, de forma que el AVR env\xede lo mas r\xe1pido posible y que Python los procese a medida que llegan. Tratando de que nunca se alcance a llegar al valor del timeout definido para la comunicacion serial."})]})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>t});var a=r(6540);const i={},s=a.createContext(i);function l(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(s.Provider,{value:n},e.children)}},9365:(e,n,r)=>{r.d(n,{A:()=>l});r(6540);var a=r(4164);const i={tabItem:"tabItem_Ymn6"};var s=r(4848);function l({children:e,hidden:n,className:r}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,a.A)(i.tabItem,r),hidden:n,children:e})}}}]);