"use strict";(globalThis.webpackChunkweb_apuntes=globalThis.webpackChunkweb_apuntes||[]).push([[298],{267:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"esp32/OTA_update","title":"Actualizaci\xf3n OTA","description":"Guia para realizar actualizaciones Over-The-Air (OTA) en dispositivos ESP32.","source":"@site/docs/08_esp32/OTA_update.mdx","sourceDirName":"08_esp32","slug":"/esp32/OTA_update","permalink":"/docs/esp32/OTA_update","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769914882000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Actualizaci\xf3n OTA","description":"Guia para realizar actualizaciones Over-The-Air (OTA) en dispositivos ESP32."},"sidebar":"tutorialSidebar","previous":{"title":"Libreria WiFiClientSecure.h","permalink":"/docs/esp32/get_post_https"}}');var t=i(4848),a=i(8453);i(1470),i(9365);const s={sidebar_position:4,title:"Actualizaci\xf3n OTA",description:"Guia para realizar actualizaciones Over-The-Air (OTA) en dispositivos ESP32."},l="Esquema de Actualizaci\xf3n OTA en ESP32",o={},c=[{value:"Introducci\xf3n",id:"introducci\xf3n",level:2},{value:"Servidor",id:"servidor",level:2},{value:"Sketch B\xe1sico",id:"sketch-b\xe1sico",level:2},{value:"Verificar la versi\xf3n del firmware en el servidor.",id:"verificar-la-versi\xf3n-del-firmware-en-el-servidor",level:3},{value:"Descargar y aplicar la actualizaci\xf3n si es necesario.",id:"descargar-y-aplicar-la-actualizaci\xf3n-si-es-necesario",level:3},{value:"Sketch Completo",id:"sketch-completo",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"esquema-de-actualizaci\xf3n-ota-en-esp32",children:"Esquema de Actualizaci\xf3n OTA en ESP32"})}),"\n","\n",(0,t.jsx)(n.h2,{id:"introducci\xf3n",children:"Introducci\xf3n"}),"\n",(0,t.jsx)(n.p,{children:"La actualizac\xf3n Over-The-Air (OTA) permite actualizar el firmware de un dispositivo ESP32 sin necesidad de conexi\xf3n f\xedsica. Esto es especialmente \xfatil para dispositivos desplegados en ubicaciones remotas. La forma preferida de implementar OTA en ESP32 es utilizando un servidor web para alojar las actualizaciones de firmware."}),"\n",(0,t.jsx)("hr",{style:{marginTop:"40px"}}),"\n","\n",(0,t.jsx)(n.h2,{id:"servidor",children:"Servidor"}),"\n",(0,t.jsx)(n.p,{children:"El primer paso es configurar un servidor web para alojar dos archivos esenciales:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"firmware.bin"}),": El archivo binario del firmware que se va a actualizar."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"version.txt"}),": Un archivo de texto que contiene la versi\xf3n actual del firmware."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"El dispositivo ESP32 verificar\xe1 de la siguiente forma:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Descargar ",(0,t.jsx)(n.code,{children:"version.txt"})," desde el servidor."]}),"\n",(0,t.jsxs)(n.li,{children:["Comparar la versi\xf3n en ",(0,t.jsx)(n.code,{children:"version.txt"})," con la versi\xf3n actual del firmware."]}),"\n",(0,t.jsxs)(n.li,{children:["Si la versi\xf3n en el servidor es m\xe1s reciente, proceder\xe1 a descargar ",(0,t.jsx)(n.code,{children:"firmware.bin"})," y actualizar el firmware."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Para el ejemplo, utilizaremos un servidor web simple al que se puede acceder desde ",(0,t.jsx)(n.code,{children:"http://apuntes.christianherrera.com.ar/ota/"}),"."]}),"\n",(0,t.jsx)("hr",{style:{marginTop:"40px"}}),"\n","\n",(0,t.jsx)(n.h2,{id:"sketch-b\xe1sico",children:"Sketch B\xe1sico"}),"\n",(0,t.jsx)(n.p,{children:"El microcontrolador tendr\xe1 dos funciones principales:"}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"verificar-la-versi\xf3n-del-firmware-en-el-servidor",children:"Verificar la versi\xf3n del firmware en el servidor."}),"\n",(0,t.jsxs)(n.p,{children:["Se utiliza el ejemplo visto en ",(0,t.jsx)(n.a,{href:"./get_post_https#petici%C3%B3n-get",children:"Solicitud GET con HTTPS"}),". La idea es solicitar el archivo ",(0,t.jsx)(n.code,{children:"version.txt"})," y devolver la versi\xf3n como un entero. En caso de error, se devolver\xe1 ",(0,t.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'int checkNewVersion() {\n    // Verifica conexi\xf3n WiFi\n    if (WiFi.status() != WL_CONNECTED) {\n        Serial.println("WiFi no conectado");\n        return -1;\n    }\n\n    // Objetos y primeras configuraciones\n    WiFiClientSecure client;\n    HTTPClient http;\n    client.setCACert(SERVER_ROOT_CA);\n    http.setTimeout(5000);\n\n    // Inicia conexi\xf3n\n    if (!http.begin(client, "https://apuntes.christianherrera.com.ar/ota/version.txt")) {\n        return -1;\n    }\n\n    // Realiza la petici\xf3n\n    int httpCode = http.GET();\n    if (httpCode != HTTP_CODE_OK) {\n        Serial.printf("HTTP error: %d\\n", httpCode);\n        http.end();\n        return -1;\n    }\n\n    // Leo el contenido de version.txt (m\xe1ximo 7 bytes)\n    char buf[8];\n    memset(buf, 0, sizeof(buf));\n    WiFiClient* stream = http.getStreamPtr();\n    size_t len = stream->readBytesUntil(\'\\n\', buf, sizeof(buf) - 1);\n    http.end();\n\n    // Convierto a entero y comparo con el actual\n    if (len == 0) return -1;\n    return(atoi(buf));\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"En este ejemplo se ven algunos detalles importantes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Utiliza HTTPS para la conexi\xf3n segura."}),"\n",(0,t.jsxs)(n.li,{children:["Lee el contenido del archivo ",(0,t.jsx)(n.code,{children:"version.txt"})," hasta un salto de l\xednea."]}),"\n",(0,t.jsx)(n.li,{children:"Utiliza un buffer de 8 bytes para almacenar la versi\xf3n le\xedda."}),"\n",(0,t.jsx)(n.li,{children:"La funci\xf3n retorna la version leida como un entero, o -1 en caso de error."}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"descargar-y-aplicar-la-actualizaci\xf3n-si-es-necesario",children:"Descargar y aplicar la actualizaci\xf3n si es necesario."}),"\n",(0,t.jsx)(n.p,{children:"La funci\xf3n para descargar y aplicar la actualizaci\xf3n OTA es la siguiente:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'void processUpdate() {\n    if (WiFi.status() != WL_CONNECTED) {\n        Serial.println("WiFi no conectado");\n        return;\n    }\n\n    // Objetos y primeras configuraciones\n    WiFiClientSecure client;\n    client.setCACert(SERVER_ROOT_CA);\n    httpUpdate.rebootOnUpdate(true);\n\n    // Inicia actualizaci\xf3n OTA\n    Serial.println("Iniciando OTA HTTPS...");\n    t_httpUpdate_return ret = httpUpdate.update(client, "https://apuntes.christianherrera.com.ar/ota/firmware.bin");\n\n    // Manejo de resultados\n    if (ret == HTTP_UPDATE_FAILED) {\n        Serial.printf("OTA fall\xf3 (%d): %s\\n", httpUpdate.getLastError(), httpUpdate.getLastErrorString().c_str());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"En este ejemplo:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Se utiliza la funci\xf3n ",(0,t.jsx)(n.code,{children:"httpUpdate.update()"})," para descargar y aplicar la actualizaci\xf3n desde el servidor."]}),"\n",(0,t.jsx)(n.li,{children:"Se maneja el resultado de la actualizaci\xf3n, imprimiendo un mensaje en caso de fallo."}),"\n",(0,t.jsx)(n.li,{children:"Si la actualizaci\xf3n es exitosa, el dispositivo se reiniciar\xe1 autom\xe1ticamente."}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"sketch-completo",children:"Sketch Completo"}),"\n",(0,t.jsxs)(n.p,{children:["A continuaci\xf3n se muestra un sketch completo que integra ambas funciones y realiza la verificaci\xf3n y actualizaci\xf3n OTA.\nPara el ejemplo, se utiliza las URL de ",(0,t.jsx)(n.code,{children:"https://raw.githubusercontent.com/..."})," dado que es la url que devuelve el ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Content-Length"})})," del archivo ",(0,t.jsx)(n.code,{children:"firmware.bin"}),". La url con dominio personal no devuelve este encabezado, lo que provoca un error en la actualizaci\xf3n OTA."]}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Archivo de Configuraci\xf3n"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ini",children:"[env:esp32-c3-devkitm-1]\nplatform = espressif32\nboard = esp32-c3-devkitm-1\nframework = arduino\nbuild_flags = \n\t-D ARDUINO_USB_MODE=1\n\t-D ARDUINO_USB_CDC_ON_BOOT=1\n\t-D CORE_DEBUG_LEVEL=0\n\t-D FIRMWARE_VERSION=1\n\nmonitor_speed = 115200\nmonitor_filters = send_on_enter, time, esp32_exception_decoder, log2file\n"})})]}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Sketch Completo"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <Arduino.h>\n#include <HTTPClient.h>\n#include <HTTPUpdate.h>\n#include <WiFi.h>\n#include <WiFiClientSecure.h>\n\nconst char* host_ssid = "WIFI_SSID";\nconst char* host_pass = "WIFI_PASS";\n\nchar buffer[128];\n\nconst char SERVER_ROOT_CA[] = R"EOF(\n-----BEGIN CERTIFICATE-----\nMIIF3jCCA8agAwIBAgIQAf1tMPyjylGoG7xkDjUDLTANBgkqhkiG9w0BAQwFADCB\niDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0pl\ncnNleSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNV\nBAMTJVVTRVJUcnVzdCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAw\nMjAxMDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBiDELMAkGA1UEBhMCVVMxEzARBgNV\nBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYDVQQKExVU\naGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBSU0EgQ2Vy\ndGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK\nAoICAQCAEmUXNg7D2wiz0KxXDXbtzSfTTK1Qg2HiqiBNCS1kCdzOiZ/MPans9s/B\n3PHTsdZ7NygRK0faOca8Ohm0X6a9fZ2jY0K2dvKpOyuR+OJv0OwWIJAJPuLodMkY\ntJHUYmTbf6MG8YgYapAiPLz+E/CHFHv25B+O1ORRxhFnRghRy4YUVD+8M/5+bJz/\nFp0YvVGONaanZshyZ9shZrHUm3gDwFA66Mzw3LyeTP6vBZY1H1dat//O+T23LLb2\nVN3I5xI6Ta5MirdcmrS3ID3KfyI0rn47aGYBROcBTkZTmzNg95S+UzeQc0PzMsNT\n79uq/nROacdrjGCT3sTHDN/hMq7MkztReJVni+49Vv4M0GkPGw/zJSZrM233bkf6\nc0Plfg6lZrEpfDKEY1WJxA3Bk1QwGROs0303p+tdOmw1XNtB1xLaqUkL39iAigmT\nYo61Zs8liM2EuLE/pDkP2QKe6xJMlXzzawWpXhaDzLhn4ugTncxbgtNMs+1b/97l\nc6wjOy0AvzVVdAlJ2ElYGn+SNuZRkg7zJn0cTRe8yexDJtC/QV9AqURE9JnnV4ee\nUB9XVKg+/XRjL7FQZQnmWEIuQxpMtPAlR1n6BB6T1CZGSlCBst6+eLf8ZxXhyVeE\nHg9j1uliutZfVS7qXMYoCAQlObgOK6nyTJccBz8NUvXt7y+CDwIDAQABo0IwQDAd\nBgNVHQ4EFgQUU3m/WqorSs9UgOHYm8Cd8rIDZsswDgYDVR0PAQH/BAQDAgEGMA8G\nA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAFzUfA3P9wF9QZllDHPF\nUp/L+M+ZBn8b2kMVn54CVVeWFPFSPCeHlCjtHzoBN6J2/FNQwISbxmtOuowhT6KO\nVWKR82kV2LyI48SqC/3vqOlLVSoGIG1VeCkZ7l8wXEskEVX/JJpuXior7gtNn3/3\nATiUFJVDBwn7YKnuHKsSjKCaXqeYalltiz8I+8jRRa8YFWSQEg9zKC7F4iRO/Fjs\n8PRF/iKz6y+O0tlFYQXBl2+odnKPi4w2r78NBc5xjeambx9spnFixdjQg3IM8WcR\niQycE0xyNN+81XHfqnHd4blsjDwSXWXavVcStkNr/+XeTWYRUc+ZruwXtuhxkYze\nSf7dNXGiFSeUHM9h4ya7b6NnJSFd5t0dCy5oGzuCr+yDZ4XUmFF0sbmZgIn/f3gZ\nXHlKYC6SQK5MNyosycdiyA5d9zZbyuAlJQG03RoHnHcAP9Dc1ew91Pq7P8yF1m9/\nqS3fuQL39ZeatTXaw2ewh0qpKJ4jjv9cJ2vhsE/zB+4ALtRZh8tSQZXq9EfX7mRB\nVXyNWQKV3WKdwrnuWih0hKWbt5DHDAff9Yk2dDLWKMGwsAvgnEzDHNb842m1R0aB\nL6KCq9NjRHDEjf8tM7qtj3u1cIiuPhnPQCjY/MiQu12ZIvVS5ljFH4gxQ+6IHdfG\njjxDah2nGN59PRbxYvnKkKj9\n-----END CERTIFICATE-----\n)EOF";\n\nint checkNewVersion() {\n    // Verifica conexi\xf3n WiFi\n    if (WiFi.status() != WL_CONNECTED) {\n        Serial.println("WiFi no conectado");\n        return -1;\n    }\n\n    // Objetos y primeras configuraciones\n    WiFiClientSecure client;\n    HTTPClient http;\n    client.setCACert(SERVER_ROOT_CA);\n    http.setTimeout(5000);\n\n    // Inicia conexi\xf3n\n    if (!http.begin(client, "https://raw.githubusercontent.com/christian-herrera/apuntes/main/static/ota/version.txt")) {\n        return -1;\n    }\n\n    // Realiza la petici\xf3n\n    int httpCode = http.GET();\n    if (httpCode != HTTP_CODE_OK) {\n        Serial.printf("HTTP error: %d\\n", httpCode);\n        http.end();\n        return -1;\n    }\n\n    // Leo el contenido de version.txt (m\xe1ximo 7 bytes)\n    char buf[8];\n    memset(buf, 0, sizeof(buf));\n    WiFiClient* stream = http.getStreamPtr();\n    size_t len = stream->readBytesUntil(\'\\n\', buf, sizeof(buf) - 1);\n    http.end();\n\n    // Convierto a entero y comparo con el actual\n    if (len == 0) return -1;\n    return(atoi(buf));\n}\n\nvoid processUpdate() {\n    if (WiFi.status() != WL_CONNECTED) {\n        Serial.println("WiFi no conectado");\n        return;\n    }\n\n    // Objetos y primeras configuraciones\n    WiFiClientSecure client;\n    client.setCACert(SERVER_ROOT_CA);\n    httpUpdate.rebootOnUpdate(true);\n    httpUpdate.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);\n\n    // Inicia actualizaci\xf3n OTA\n    Serial.println("Iniciando OTA HTTPS...");\n    t_httpUpdate_return ret = httpUpdate.update(client, "https://raw.githubusercontent.com/christian-herrera/apuntes/main/static/ota/firmware.bin");\n\n    // Manejo de resultados\n    if (ret == HTTP_UPDATE_FAILED) {\n        Serial.printf("OTA fall\xf3 (%d): %s\\n", httpUpdate.getLastError(), httpUpdate.getLastErrorString().c_str());\n    }\n}\n\nvoid setup() {\n    analogWrite(8, 255);\n    Serial.begin(115200);\n    delay(3000);\n\n    // Modo STA\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(host_ssid, host_pass);\n\n    // Espera hasta conectarse\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n    }\n    Serial.println("\\nConectado!");\n\n    // Verificacion\n    analogWrite(8, 0);\n    Serial.printf("Version actual: %d\\n", FIRMWARE_VERSION);\n    int newVersion = checkNewVersion();\n    if(newVersion > FIRMWARE_VERSION) {\n        Serial.printf("Nueva version disponible: %d (actual: %d)\\n", newVersion, FIRMWARE_VERSION);\n        delay(3000);\n        processUpdate();\n    } else {\n        Serial.println("No hay nueva version disponible.");\n    }\n    analogWrite(8, 255);\n    delay(1000);\n}\n\nvoid loop() {\n\n    static unsigned long mark = 0;\n    static int level = 0;\n    static bool direction = false;\n    if (millis() - mark > 10) {\n        mark = millis();\n        analogWrite(8, level);\n        level = level + (direction ? 1 : -1);\n        direction = (level >= 255) ? false : (level <= 0) ? true : direction;\n    }\n}\n'})})]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1470:(e,n,i)=>{i.d(n,{A:()=>j});var r=i(6540),t=i(4164),a=i(7559),s=i(3104),l=i(6347),o=i(205),c=i(7485),d=i(1682),u=i(679);function p(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:i}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return p(e).map(({props:{value:e,label:n,attributes:i,default:r}})=>({value:e,label:n,attributes:i,default:r}))}(i);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,i])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function f({queryString:e=!1,groupId:n}){const i=(0,l.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(t),(0,r.useCallback)(e=>{if(!t)return;const n=new URLSearchParams(i.location.search);n.set(t,e),i.replace({...i.location,search:n.toString()})},[t,i])]}function v(e){const{defaultValue:n,queryString:i=!1,groupId:t}=e,a=h(e),[s,l]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find(e=>e.default)??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:a})),[c,d]=f({queryString:i,groupId:t}),[p,v]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,t]=(0,u.Dv)(n);return[i,(0,r.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:t}),b=(()=>{const e=c??p;return m({value:e,tabValues:a})?e:null})();(0,o.A)(()=>{b&&l(b)},[b]);return{selectedValue:s,selectValue:(0,r.useCallback)(e=>{if(!m({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),v(e)},[d,v,a]),tabValues:a}}var b=i(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var A=i(4848);function x({className:e,block:n,selectedValue:i,selectValue:r,tabValues:a}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,s.a_)(),c=e=>{const n=e.currentTarget,t=l.indexOf(n),s=a[t].value;s!==i&&(o(n),r(s))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const i=l.indexOf(e.currentTarget)+1;n=l[i]??l[0];break}case"ArrowLeft":{const i=l.indexOf(e.currentTarget)-1;n=l[i]??l[l.length-1];break}}n?.focus()};return(0,A.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:a.map(({value:e,label:n,attributes:r})=>(0,A.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...r,className:(0,t.A)("tabs__item",g.tabItem,r?.className,{"tabs__item--active":i===e}),children:n??e},e))})}function T({lazy:e,children:n,selectedValue:i}){const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=a.find(e=>e.props.value===i);return e?(0,r.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,A.jsx)("div",{className:"margin-top--md",children:a.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==i}))})}function E(e){const n=v(e);return(0,A.jsxs)("div",{className:(0,t.A)(a.G.tabs.container,"tabs-container",g.tabList),children:[(0,A.jsx)(x,{...n,...e}),(0,A.jsx)(T,{...n,...e})]})}function j(e){const n=(0,b.A)();return(0,A.jsx)(E,{...e,children:p(e.children)},String(n))}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var r=i(6540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}},9365:(e,n,i)=>{i.d(n,{A:()=>s});i(6540);var r=i(4164);const t={tabItem:"tabItem_Ymn6"};var a=i(4848);function s({children:e,hidden:n,className:i}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(t.tabItem,i),hidden:n,children:e})}}}]);