"use strict";(globalThis.webpackChunkweb_apuntes=globalThis.webpackChunkweb_apuntes||[]).push([[994],{844:(e,a,i)=>{i.r(a),i.d(a,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"esp32/partitions","title":"Particiones de Memoria","description":"Esquema de particiones de memoria en ESP32 y su configuraci\xf3n para actualizaciones OTA.","source":"@site/docs/08_esp32/partitions.mdx","sourceDirName":"08_esp32","slug":"/esp32/partitions","permalink":"/docs/esp32/partitions","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769978918000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Particiones de Memoria","description":"Esquema de particiones de memoria en ESP32 y su configuraci\xf3n para actualizaciones OTA."},"sidebar":"tutorialSidebar","previous":{"title":"Hello World","permalink":"/docs/esp32/hello_world"},"next":{"title":"Libreria WiFi.h","permalink":"/docs/esp32/wifi_lib"}}');var n=i(4848),r=i(8453);const o={sidebar_position:2,title:"Particiones de Memoria",description:"Esquema de particiones de memoria en ESP32 y su configuraci\xf3n para actualizaciones OTA."},c="Particiones de Memoria",d={},l=[{value:"Introducci\xf3n",id:"introducci\xf3n",level:2},{value:"Esquema para Desarrollo",id:"esquema-para-desarrollo",level:2},{value:"Esquema para Producci\xf3n (con OTA)",id:"esquema-para-producci\xf3n-con-ota",level:2}];function t(e){const a={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.header,{children:(0,n.jsx)(a.h1,{id:"particiones-de-memoria",children:"Particiones de Memoria"})}),"\n","\n",(0,n.jsx)(a.h2,{id:"introducci\xf3n",children:"Introducci\xf3n"}),"\n",(0,n.jsxs)(a.p,{children:["El ESP32 utiliza un esquema de particiones de memoria para organizar el almacenamiento interno del dispositivo. Este esquema es crucial para gestionar el firmware, los datos del usuario y las actualizaciones Over-The-Air (OTA). La definicion de estas particiones las realiza PlatformIO a traves del archivo ",(0,n.jsx)(a.code,{children:"partitions.csv"}),", pero este mismo se puede editar para personalizar el esquema de particiones segun las necesidades del proyecto."]}),"\n",(0,n.jsxs)(a.p,{children:["La version por defecto de PlatformIO para ESP32 es ",(0,n.jsx)(a.code,{children:"default.csv"})," y contiene las siguientes particiones:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csv",children:"# Name,   Type, SubType, Offset,  Size, Flags\nnvs,      data, nvs,     0x9000,  0x5000,\notadata,  data, ota,     0xe000,  0x2000,\napp0,     app,  ota_0,   0x10000, 0x140000,\napp1,     app,  ota_1,   0x150000,0x140000,\nspiffs,   data, spiffs,  0x290000,0x160000,\ncoredump, data, coredump,0x3F0000,0x10000,\n"})}),"\n",(0,n.jsxs)(a.p,{children:["Es importante entender que el microcontrolador dispone de una memoria flash de 4MB pero la misma es accesible a partir de la posicion ",(0,n.jsx)(a.code,{children:"0x9000"})," ya que las primeras posiciones estan reservadas para el bootloader y otras funciones internas del ESP32."]}),"\n",(0,n.jsxs)(a.p,{children:["En este esquema, los siguientes ",(0,n.jsx)("u",{children:"tipos"})," de particiones:"]}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"data"})}),": Almacena datos persistentes del sistema y del usuario. Es usado por ",(0,n.jsx)(a.code,{children:"WiFi"}),", ",(0,n.jsx)(a.code,{children:"Bluetooth"}),", ",(0,n.jsx)(a.code,{children:"Preferences"}),", entre otros.","\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"nvc"})}),": Almacena la configuracion de red y otros parametros del sistema.",(0,n.jsx)(a.strong,{children:"(SIempre debe estar presente)"}),"."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"ota"})}),": Almacena informacion sobre las particiones OTA, por ejemplo, cual es la particion activa y cual es la siguiente para actualizaciones OTA."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"spiffs"})}),": Sistema de archivos SPIFFS para almacenar archivos del usuario. Por ejemplo: certificados, configuraciones, logs, etc."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"coredump"})}),": Almacena volcados de memoria en caso de fallos del sistema."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"phy_init"})}),": Almacena datos de inicializacion del PHY para WiFi y Bluetooth."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"app"})}),": Almacena las aplicaciones (firmware) que se ejecutan en el dispositivo.","\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"ota_0"})})," y ",(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"ota_1"})}),": Particiones para aplicaciones OTA. Permiten tener dos versiones del firmware para actualizaciones seguras."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.em,{children:(0,n.jsx)(a.strong,{children:"factory"})}),": Particion para la aplicacion de fabrica. Usada cuando no se utilizan actualizaciones OTA."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["En las siguientes secciones, se presentan dos esquemas de particiones recomendados: uno para entornos de desarrollo y otro para entornos de produccion con soporte para actualizaciones OTA. La forma de que PlatformIO utilice un esquema de particiones personalizado es especificando el archivo ",(0,n.jsx)(a.code,{children:"partitions.csv"})," en el archivo ",(0,n.jsx)(a.code,{children:"platformio.ini"})," de la siguiente manera:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-ini",children:"board_build.partitions = partitions_prod.csv\n; board_build.partitions = partitions_dev.csv\n"})}),"\n",(0,n.jsxs)(a.admonition,{title:"Nota importante!",type:"warning",children:[(0,n.jsxs)(a.p,{children:["Recordar que el bootloader requiere que las memorias del tipo ",(0,n.jsx)(a.code,{children:"data"})," y ",(0,n.jsx)(a.code,{children:"app"})," se deben alinear de forma distinta:"]}),(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:["Las particiones del tipo ",(0,n.jsx)(a.code,{children:"data"})," deben estar alineadas a 0x1000 (4KB)."]}),"\n",(0,n.jsxs)(a.li,{children:["Las particiones del tipo ",(0,n.jsx)(a.code,{children:"app"})," deben estar alineadas a 0x10000 (64KB)."]}),"\n"]})]}),"\n",(0,n.jsx)("hr",{style:{marginTop:"40px"}}),"\n","\n",(0,n.jsx)(a.h2,{id:"esquema-para-desarrollo",children:"Esquema para Desarrollo"}),"\n",(0,n.jsx)(a.p,{children:"Para entornos de desarrollo, es recomendable utilizar un esquema de particiones que maximice el espacio disponible para la aplicaci\xf3n y los datos del usuario. A continuacion se muestra un ejemplo de un esquema de particiones optimizado para desarrollo:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csv",children:"# Name,     Type, SubType, Offset,  Size\nnvs,        data, nvs,     0x9000,  0x3000\nphy_init,   data, phy,     0xC000,  0x1000\napp0,       app,  ota_0,   0x10000, 0x280000\nspiffs,     data, spiffs,  0x290000,0xA0000\ncoredump,   data, coredump,0x330000,0x10000\n"})}),"\n",(0,n.jsx)(a.p,{children:"En este esquema, se define:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"nvs"}),": 12KB para almacenar configuraciones del sistema."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"phy_init"}),": 4KB para datos de inicializacion del PHY."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"app0"}),": 2.5MB para la aplicacion principal, maximizando el espacio disponible."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"spiffs"}),": 640KB para almacenamiento de archivos del usuario."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"coredump"}),": 64KB para almacenar volcados de memoria en caso de fallos."]}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["No se incluye una segunda particion ",(0,n.jsx)(a.code,{children:"app1"})," para OTA, ya que en un entorno de desarrollo, las actualizaciones OTA no son una prioridad. Esto permite asignar mas espacio a la aplicacion principal y al sistema de archivos SPIFFS."]}),"\n",(0,n.jsx)("hr",{style:{marginTop:"40px"}}),"\n","\n",(0,n.jsx)(a.h2,{id:"esquema-para-producci\xf3n-con-ota",children:"Esquema para Producci\xf3n (con OTA)"}),"\n",(0,n.jsx)(a.p,{children:"Para entornos de produccion, es esencial contar con un esquema de particiones que soporte actualizaciones OTA para garantizar que el dispositivo pueda recibir mejoras y correcciones de errores despues de su despliegue. Un esquema recomendado para produccion es el siguiente:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csv",children:"# Name,   Type, SubType, Offset,  Size\nnvs,      data, nvs,     0x9000,  0x4000\notadata,  data, ota,     0xD000,  0x2000\nphy_init, data, phy,     0xF000,  0x1000\napp0,     app,  ota_0,   0x10000, 0x1E0000\napp1,     app,  ota_1,   0x1F0000,0x1E0000\n"})}),"\n",(0,n.jsx)(a.p,{children:"Bajo esta estructura, se define:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"nvs"}),": 16KB para almacenar configuraciones del sistema."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"otadata"}),": 8KB para gestionar las particiones OTA."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"phy_init"}),": 4KB para datos de inicializacion del PHY."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"app0"})," y ",(0,n.jsx)(a.code,{children:"app1"}),": 1.875MB cada una para las dos versiones del firmware, permitiendo actualizaciones OTA seguras."]}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"Este esquema garantiza que el dispositivo pueda actualizar su firmware sin interrumpir su funcionamiento, ya que siempre habra una version estable del firmware disponible en caso de que la actualizacion falle."})]})}function p(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(t,{...e})}):t(e)}},8453:(e,a,i)=>{i.d(a,{R:()=>o,x:()=>c});var s=i(6540);const n={},r=s.createContext(n);function o(e){const a=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(r.Provider,{value:a},e.children)}}}]);